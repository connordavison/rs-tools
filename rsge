#!/usr/bin/python
""" Don't forget to read: http://services.runescape.com/m=rswiki/en/Grand_Exchange__APIs """
""" And also...: http://en.wikipedia.org/wiki/Levenshtein_distance """
""" And...: http://en.wikipedia.org/wiki/Metaphone#Double_Metaphone """
try:
	import json
	from datetime import datetime
	from getopt import getopt
	from levenshtein import distance
	import os
	import re
	import requests
	import time
	import traceback
	from metaphone import doublemetaphone
	import sys
except ImportError as e:
	print e
	print 'Ensure that /usr/bin/python is a python 2.7 shell.'
	exit(99)

class rsitem:
	# where are we digging?
	# append id and '.json' to the end of __HISTORY_API_URL. Weird, right?
	__HISTORY_API_URL = 'http://services.runescape.com/m=itemdb_rs/api/graph/'
	__API_URL = 'http://services.runescape.com/m=itemdb_rs/api/catalogue/detail.json'

	# where are the articles stored?
	# after the information has been gotten, the article url must be
	# constructed by:
	#	__ART_URL + item_name + '/' + __ART_SCRIPT + item_id
	__ART_URL = 'http://services.runescape.com/m=itemdb_rs/'
	__ART_SCRIPT = 'viewitem.ws?obj='

	# what items are tradeable
	cfg_tradeables = 'cfg_tradeables.txt'

	def __init__(self, item_name):
		#print 'Loading item database ...'

		# load tradeable item db
		self.tradeables = list()
		try:
			with open(os.path.dirname(os.path.realpath(__file__)) + '/' + self.cfg_tradeables) as cfg:
				for l in cfg:
					l = l.split('\t')
					l[1] = l[1].lower()
					l[1] = re.sub('[\n\r]', '', l[1])
					l[0] = int(l[0])
					self.tradeables.append(l)
		except Exception as e:
			print 'Error in tradeables configuration. Exiting.'
			print e
			exit(1)

		self.__make__(item_name)

	# returns a tuple, [0] = id, [1] = name
	def get_item_by_match(self, item_name):
		# standardise the input
		item_name = item_name.lower()

		# save the metaphone of the item requested to save time
		item_phon = doublemetaphone(item_name)

		possible_matches = list()
		for item in self.tradeables:
			# the lev distance of item_name and item[1]
			pure_dist = distance(item[1], str(item_name))

			# the lev distance of the metaphones
			phon_dist = distance(item_phon[0], doublemetaphone(item[1])[0])

			# add this item to the list of possibles as a
			# tuple. Left is the item id, right is the product 
			# of distances.
			possible_matches.append((item,phon_dist,pure_dist))
			# debug:
			# print 'phon dist: ' + str(phon_dist) + ', pure_dist: ' + str(pure_dist) + ', item: ' + str(item)

		# rank the matches based on tuple right
		ranked = sorted(possible_matches, key = lambda t: t[1]*t[2])
		return ranked[0][0]

	def get_change_today(self):
		return self.__change_today

	def get_id(self):
		return self.__id

	def get_name(self):
		return self.__name

	def get_description(self):
		return self.__description

	def get_price(self):
		return self.__price

	def get_proper_name(self):
		return self._name.replace(' ','_')
		
	def get_public_url(self):
		try:
			return self.__ART_URL + self.get_name().replace(' ','_') + '/' \
				+ self.__ART_SCRIPT + str(self.get_id())
		except Exception as e:
			print e
			return None

	def get_type(self):
		return self.__type

	def __make__(self, item_name):
		#get main details
		item_id = self.get_item_by_match(item_name)[0]

		params = {}
		params['item'] = item_id

		dump = requests.get(self.__API_URL, params = params)

		dump.raise_for_status()

		dump = dump.json()['item']
		
		self.__id = dump['id']
		self.__name = dump['name']
		self.__type = dump['type']
		self.__description = dump['description']
		self.__price = dump['current']['price']
		self.__change_today = dump['today']['price']

		#get details about price history (daily and average)
		dump = requests.get(self.__HISTORY_API_URL + str(item_id) + '.json').json()
		self.__daily_history = dump['daily']

	def to_string(self):
		out =  'Name:         ' + self.get_name() + '\n'
		out += 'Type:         ' + self.get_type() + '\n'
		out += 'Description:  ' + self.get_description() + '\n'
		out += 'Price:        ' + str(self.get_price()) + '\n'
		out += 'Change today: ' + str(self.get_change_today()) + '\n\n'

		out += self.get_public_url()
		return out

	def to_string_avg_history(self, limit = 10):
		out =  'Name:         ' + self.get_name() + '\n'
		i = 0
		#keys = reversed(self.__average_history.keys())
		keys = reversed(sorted(self.__average_history.keys()))
		for k in keys:
			if i > limit - 1: break
			v = self.__daily_history[k]
			out += str(datetime.fromtimestamp(long(k)/1000.0)) + ":\t" + str(v) + "\n"
			i += 1
		return out

if __name__ == "__main__":
	err_msg = 'rsge [ -hipa ] [ -P num_records ] item0 [ item1 [ item2 ... ]]'
	help_msg = 'NAME:\n' + \
		'\trsge - retrieve information from the Grand Exchange.\n\n' + \
		'USAGE:\n' + \
		'\trsge [OPTIONS] item0 [ item1 [ item2 ... ]]\n\n' + \
		'\tObtains information about items item0, item1, item2, etc. This script\n' + \
		'\tutilises a local database (stored in the same directory as this script)\n' + \
		'\tentitled \'cfg_tradeables.txt\' by default. In this database are item\n' + \
		'\tname/ID pairs in the format:\n\n' + \
		'\t\tNAME\\tID\\n\n\n' + \
		'\tThis script uses a string comparison algorithm to find the best matches\n' + \
		'\tfor particular queries. For example, the string `abyzzul_wip` would\n' + \
		'\tconveniently match `Abyssal whip` in the database.\n\n'
		'OPTIONS:\n' + \
		'\t-h\n' + \
		'\t\tDisplay this help text.\n\n' + \
		'\t-i\n' + \
		'\t\tPrint item ID.\n\n' + \
		'\t-p\n' + \
		'\t\tPrint price history.\n\n' + \
		'\t-P num_records\n' + \
		'\t\tPrint `num_records` records.\n'
	try:
		opts, args = getopt(sys.argv[1:], "hipP:")
	except:
		print err_msg
		exit(1)

	print_id = False
	print_history = False
	print_average_history = True
	num_records = 10

	for flag, value in opts:
		if flag == '-i':
			print_id = True
		elif flag == '-p' or flag == '-P':
			if print_history: continue
			print_history = True
			if flag == '-P':
				try:
					num_records = int(value)
				except ValueError:
					print '-P requires a number.'
					print err_msg
		elif flag == '-a':
			print_average_history = True
		elif flag == '-h':
			print help_msg
			exit(0)

	if not args:
		print err_msg
		exit(2)

	for arg in args:
		rsi = rsitem(arg)
		if print_id:
			print rsi.get_id()
		if print_history:
			print rsi.to_string_avg_history(limit = num_records)
		else:
			print rsi.to_string()