#!/usr/bin/python
""" Don't forget to read: http://services.runescape.com/m=rswiki/en/Grand_Exchange__APIs """
""" And also...: http://en.wikipedia.org/wiki/Levenshtein_distance """
""" And...: http://en.wikipedia.org/wiki/Metaphone#Double_Metaphone """
try:
	import json
	from datetime import datetime
	from errors import *
	from getopt import getopt
	from levenshtein import distance
	import re
	import requests
	import time
	import traceback
	from metaphone import doublemetaphone
	import sys
except ImportError as e:
	print e
	print 'Ensure that /usr/bin/python is a python 2.7 shell.'
	exit(99)

class rsitem:
	# where are we digging?
	# append id and '.json' to the end of __HISTORY_API_URL. Weird, right?
	__HISTORY_API_URL = 'http://services.runescape.com/m=itemdb_rs/api/graph/'
	__API_URL = 'http://services.runescape.com/m=itemdb_rs/api/catalogue/detail.json'

	# where are the articles stored?
	# after the information has been gotten, the article url must be
	# constructed by:
	#	__ART_URL + item_name + '/' + __ART_SCRIPT + item_id
	__ART_URL = 'http://services.runescape.com/m=itemdb_rs/'
	__ART_SCRIPT = 'viewitem.ws?obj='

	# what items are tradeable
	cfg_tradeables = 'cfg_tradeables.txt'

	# levenshtein tolerance for matching pure strings (dist < _pure_tol)
	_pure_tol = 5
	
	# levenshtein tolerance for matching phonetic strings (dist < _phon_tol)
	_phon_tol = 3

	def __init__(self, item_name):
		#print 'Loading item database ...'

		# load tradeable item db
		self.tradeables = list()
		try:
			with open(self.cfg_tradeables) as cfg:
				for l in cfg:
					l = l.split('\t')
					l[1] = l[1].lower()
					l[1] = re.sub('[\n\r]', '', l[1])
					l[0] = int(l[0])
					self.tradeables.append(l)
		except Exception:
			print 'Error in tradeables configuration. Exiting.'
			exit(1)

		self.__make__(item_name)

	# returns a tuple, [0] = id, [1] = name
	def get_item_by_match(self, item_name):
		# standardise the input
		item_name = item_name.lower()

		# save the metaphone of the item requested to save time
		item_phon = doublemetaphone(item_name)

		possible_matches = list()
		for item in self.tradeables:
			# the lev distance of item_name and item[1]
			pure_dist = distance(item[1], str(item_name))

			# the lev distance of the metaphones
			phon_dist = distance(item_phon[0], doublemetaphone(item[1])[0])

			# add this item to the list of possibles as a
			# tuple. Left is the item id, right is the product 
			# of distances.
			possible_matches.append((item,phon_dist,pure_dist))
			# debug:
			# print 'phon dist: ' + str(phon_dist) + ', pure_dist: ' + str(pure_dist) + ', item: ' + str(item)

		# if we have multiple results
		if len(possible_matches) > 0:
			# rank the matches based on tuple right
			ranked = sorted(possible_matches, key = lambda t: t[1]*t[2])

			# find the first legal ranked item and return
			for i in range(len(ranked)):
				if ranked[i][1] < self._phon_tol and ranked[i][2] < self._pure_tol:
					self._id = ranked[i][0][0]
					self._name = ranked[i][0][1]
					return ranked[i][0]

		raise NoSuchItemError('No item could be found by the specified name.')

	def get_change_today(self):
		return self.__change_today

	def get_id(self):
		return self.__id

	def get_name(self):
		return self.__name

	def get_description(self):
		return self.__description

	def get_price(self):
		return self.__price

	def get_proper_name(self):
		return self._name.replace(' ','_')
		
	def get_public_url(self):
		try:
			return self.__ART_URL + self._name.replace(' ','_') + '/' \
				+ self.__ART_SCRIPT + str(self._id)
		except:
			return None

	def get_type(self):
		return self.__type

	def __make__(self, item_name):
		try:
			#get main details
			item_id = self.get_item_by_match(item_name)[0]

			params = {}
			params['item'] = item_id

			dump = requests.get(self.__API_URL, params = params)

			dump = dump.json()['item']
			
			self.__name = dump['name']
			self.__type = dump['type']
			self.__description = dump['description']
			self.__price = dump['current']['price']
			self.__change_today = dump['today']['price']

			#get details about price history (daily and average)
			dump = requests.get(self.__HISTORY_API_URL + str(item_id) + '.json').json()
			self.__daily_history = dump['daily']
			self.__average_history = dump['daily']
		except Exception as e:
			print e

	def to_string(self):
		out =  'Name:         ' + self.get_name() + '\n'
		out += 'Type:         ' + self.get_type() + '\n'
		out += 'Description:  ' + self.get_description() + '\n'
		out += 'Price:        ' + self.get_price() + '\n'
		out += 'Change today: ' + self.get_change_today() + '\n\n'

		out += self.get_public_url()
		return out

	def to_string_avg_history(self, limit = 10):
		out =  'Name:         ' + self.get_name() + '\n'
		i = 0
		keys = reversed(self.__average_history.keys())
		for k in keys:
			if i > limit - 1: break
			v = self.__daily_history[k]
			out += str(datetime.fromtimestamp(long(k)/1000.0)) + ":\t" + str(v) + "\n"
			i += 1
		return out

	def to_string_daily_history(self, limit = 10):
		out = ""
		i = 0
		keys = reversed(self.__daily_history.keys())
		for k in keys:
			if i > limit - 1: break
			v = self.__daily_history[k]
			out += str(datetime.fromtimestamp(long(k)/1000.0)) + ":\t" + str(v) + "\n"
			i += 1
		return out

if __name__ == "__main__":
	err_msg = 'rsge [ -h ] [ -i ] [ item_name ]'

	try:
		opts, args = getopt(sys.argv[1:], "hipP:a")
	except:
		print err_msg
		exit(1)

	print_id = False
	print_history = False
	print_average_history = True
	num_records = 10

	for flag, value in opts:
		if flag == '-i':
			print_id = True
		elif flag == '-p' or flag == '-P':
			if print_history: continue
			print_history = True
			if flag == '-P':
				try:
					num_records = int(value)
				except ValueError:
					print '-P requires a number.'
					print err_msg
		elif flag == '-a':
			print_average_history = True
		elif flag == '-h':
			print err_msg
			exit(3)

	if not args:
		print err_msg
		exit(2)

	for arg in args:
		rsi = rsitem(arg)
		if print_id:
			print rsi.get_id()
		if print_history:
			if print_average_history:
				print rsi.to_string_avg_history()
			else:
				print rsi.to_string_daily_history()
		else:
			print rsi.to_string()